---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# jentre

<!-- badges: start -->
[![R-CMD-check](https://github.com/cidm-ph/jentre/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/cidm-ph/jentre/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

jentre is a client for the NCBI's Entrez API.

The Entrez API has many quirks. jentre attempts to deal with those while presenting
a convenient interface. It is designed for bulk metadata fetching and link traversal,
though also provides full access to other parts of Entrez, albeit with fewer helpers.

Features of jentre:

  * Provides objects representing sets of Entrez identifiers to avoid mixing them up
  * Batches requests behind the scenes when needed
  * Based on {httr2} and {xml2}

The {rentrez} package is more mature and might suit a broader set of applications.


## Installation

You can install the development version of jentre like so:

``` r
# development version
install.packages('jentre', repos = c('https://cidm-ph.r-universe.dev', 'https://cloud.r-project.org'))
```

## Example

```{r, echo=FALSE}
c(
  "esearch_web_history.xml",
  "elink_wh.xml",
  "entrez_translate_web_history.xml",
  "esummary_sra.xml",
  "esearch_demo.xml"
) |>
  purrr::map(function(path) {
    path <- file.path("tests/responses", path)
    httr2::response(
      status_code = 200,
      headers = c("Content-Type: application/xml"),
      body = readBin(path, "raw", file.size(path))
    )
  }) |>
  httr2::local_mocked_responses()
```

```{r example}
library(jentre)

# Searches by default use the Entrez history server for efficiency:
results <- esearch("Corynebacterium diphtheriae[orgn]", "biosample")
results

# The returned object keeps track of which database the UIDs belong to,
# and whether the UIDs are local or on the history server. This makes
# them easier and less error-prone to use:
links <- elink(results, "sra")
links

# You can pull a list of UIDs from the history server:
ids <- as_id_list(links$to[[1]])

# This is a vector with some extra metadata attached, but can be
# subsetted normally:
head(ids, n = 10)
as.character(ids[4:8])

# For endpoints with richer data, you can provide an function to
# extract data you care about from the XML document. The output is
# combined if multiple API requests are needed, so you can end up
# with a single combined data frame, list, or vector:
esummary(
  ids[1:20],
  .process = function(doc) {
    xml2::xml_find_all(doc, "//DocumentSummary/CreateDate") |> xml2::xml_text()
  }
)

# If needed, you can construct an arbitrary request:
req <- entrez_request("esearch.fcgi", db = "nucleotide", term = "biomol+trna[prop]")
# You'll need to execute and parse it yourself:
httr2::req_perform(req) |> httr2::resp_body_xml()
```
